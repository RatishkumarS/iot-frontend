{"ast":null,"code":"import React,{useEffect,useState}from'react';import{Line}from'react-chartjs-2';import socketIOClient from'socket.io-client';// Use environment variable for the endpoint, fallback to localhost for development\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const endpoint=process.env.REACT_APP_API_URL||\"http://localhost:3000\";function DarknessChart(){// Initialize chart data from localStorage; update state when new sensor data is received\nconst[c,setChart]=useState(()=>{const s=localStorage.getItem('darknessChartData');return s?JSON.parse(s):{labels:[],datasets:[{label:'Darkness',data:[],fill:false,backgroundColor:'black',borderColor:'black'}]};});// Connect to the backend server through websockets and update chart data on incoming sensor readings.\nuseEffect(()=>{const socket=socketIOClient(endpoint,{transports:[\"websocket\"]});socket.on('mqtt_message',data=>{if(data.topic==='sensors/ldr'){try{const dataObj=JSON.parse(data.message);const d=parseFloat(dataObj.darkness);if(!isNaN(d)){const darkValue=d;// sensor darkness value (a decimal between 0 and 1)\nconst cTime=new Date().toLocaleTimeString();setChart(prevData=>{const newLabels=[...prevData.labels,cTime];const newData=[...prevData.datasets[0].data,darkValue];// Keep only the last 10 data points.\nif(newLabels.length>10){newLabels.splice(0,newLabels.length-10);newData.splice(0,newData.length-10);}const charts={labels:newLabels,datasets:[{...prevData.datasets[0],data:newData}]};// Save the updated chart data to localStorage.\nlocalStorage.setItem('darknessChartData',JSON.stringify(charts));return charts;});}}catch(error){console.error(\"Error parsing LDR sensor data\",error);}}});return()=>socket.disconnect();},[]);return/*#__PURE__*/_jsxs(\"div\",{style:{width:'100%',maxWidth:'600px'},children:[/*#__PURE__*/_jsx(\"h5\",{children:\"Darkness vs. Time\"}),/*#__PURE__*/_jsx(Line,{data:c})]});}export default DarknessChart;","map":{"version":3,"names":["React","useEffect","useState","Line","socketIOClient","jsx","_jsx","jsxs","_jsxs","endpoint","process","env","REACT_APP_API_URL","DarknessChart","c","setChart","s","localStorage","getItem","JSON","parse","labels","datasets","label","data","fill","backgroundColor","borderColor","socket","transports","on","topic","dataObj","message","d","parseFloat","darkness","isNaN","darkValue","cTime","Date","toLocaleTimeString","prevData","newLabels","newData","length","splice","charts","setItem","stringify","error","console","disconnect","style","width","maxWidth","children"],"sources":["/Users/ratishkumarsaravanan/Desktop/Final-project/front/iot-frontend/src/DarknessChart.js"],"sourcesContent":["import React, { useEffect, useState } from 'react';\nimport { Line } from 'react-chartjs-2';\nimport socketIOClient from 'socket.io-client';\n\n// Use environment variable for the endpoint, fallback to localhost for development\nconst endpoint = process.env.REACT_APP_API_URL || \"http://localhost:3000\";\n\nfunction DarknessChart() {\n  // Initialize chart data from localStorage; update state when new sensor data is received\n  const [c, setChart] = useState(() => {\n    const s = localStorage.getItem('darknessChartData');\n    return s\n      ? JSON.parse(s)\n      : {\n          labels: [],\n          datasets: [{\n            label: 'Darkness',\n            data: [],\n            fill: false,\n            backgroundColor: 'black',\n            borderColor: 'black',\n          }]\n        };\n  });\n\n  // Connect to the backend server through websockets and update chart data on incoming sensor readings.\n  useEffect(() => {\n    const socket = socketIOClient(endpoint, { transports: [\"websocket\"] });\n\n    socket.on('mqtt_message', (data) => {\n      if (data.topic === 'sensors/ldr') {\n        try {\n          const dataObj = JSON.parse(data.message);\n          const d = parseFloat(dataObj.darkness);\n          if (!isNaN(d)) {\n            const darkValue = d; // sensor darkness value (a decimal between 0 and 1)\n            const cTime = new Date().toLocaleTimeString();\n\n            setChart(prevData => {\n              const newLabels = [...prevData.labels, cTime];\n              const newData = [...prevData.datasets[0].data, darkValue];\n              // Keep only the last 10 data points.\n              if (newLabels.length > 10) {\n                newLabels.splice(0, newLabels.length - 10);\n                newData.splice(0, newData.length - 10);\n              }\n              const charts = {\n                labels: newLabels,\n                datasets: [\n                  { ...prevData.datasets[0], data: newData }\n                ]\n              };\n              // Save the updated chart data to localStorage.\n              localStorage.setItem('darknessChartData', JSON.stringify(charts));\n              return charts;\n            });\n          }\n        } catch (error) {\n          console.error(\"Error parsing LDR sensor data\", error);\n        }\n      }\n    });\n\n    return () => socket.disconnect();\n  }, []);\n\n  return (\n    <div style={{ width: '100%', maxWidth: '600px' }}>\n      <h5>Darkness vs. Time</h5>\n      <Line data={c} />\n    </div>\n  );\n}\n\nexport default DarknessChart;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}